# Ephemeral Root CA Taskfile
# https://taskfile.dev

version: '3'

vars:
  AGE_KEY_FILE: age.key
  SECRETS_DIR: secrets
  ENCRYPTED_DIR: encrypted
  BAO_ADDR: http://127.0.0.1:8200
  ROOT_CA_CONFIG_FILE: config/root-ca.json
  # Root CA configuration
  ROOT_CA_TTL: "87600h"  # 10 years
  ROOT_CA_CN:
    sh: |
      if [ -f "{{.ROOT_CA_CONFIG_FILE}}" ]; then
        jq -r '.name // "Ephemeral Root CA"' "{{.ROOT_CA_CONFIG_FILE}}"
      else
        echo "Ephemeral Root CA"
      fi
  ROOT_CA_ORG:
    sh: |
      if [ -f "{{.ROOT_CA_CONFIG_FILE}}" ]; then
        jq -r '.organization // "Ephemeral PKI"' "{{.ROOT_CA_CONFIG_FILE}}"
      else
        echo "Ephemeral PKI"
      fi
  ROOT_CA_BASE_URL:
    sh: |
      if [ -f "{{.ROOT_CA_CONFIG_FILE}}" ]; then
        DOMAIN=$(jq -r '.domain // ""' "{{.ROOT_CA_CONFIG_FILE}}")
        if [ -n "$DOMAIN" ] && [ "$DOMAIN" != "null" ]; then
          case "$DOMAIN" in
            http://*|https://*) printf "%s" "$DOMAIN" ;;
            *) printf "https://%s" "$DOMAIN" ;;
          esac
          exit 0
        fi
      fi
      printf "%s" "{{.BAO_ADDR}}"
  SUB_CA_CONFIG_FILE: config/sub-ca.json
  SUB_CA_MOUNT:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        VALUE=$(jq -r '.mount // ""' "{{.SUB_CA_CONFIG_FILE}}")
        if [ -n "$VALUE" ] && [ "$VALUE" != "null" ]; then
          printf "%s" "$VALUE"
          exit 0
        fi
      fi
      printf "%s" "pki_int"
  SUB_CA_TTL:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        VALUE=$(jq -r '.ttl // ""' "{{.SUB_CA_CONFIG_FILE}}")
        if [ -n "$VALUE" ] && [ "$VALUE" != "null" ]; then
          printf "%s" "$VALUE"
          exit 0
        fi
      fi
      printf "%s" "43800h"
  SUB_CA_CN:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        jq -r '.name // "Ephemeral Issuing CA"' "{{.SUB_CA_CONFIG_FILE}}"
      else
        echo "Ephemeral Issuing CA"
      fi
  SUB_CA_ORG:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        VALUE=$(jq -r '.organization // ""' "{{.SUB_CA_CONFIG_FILE}}")
        if [ -n "$VALUE" ] && [ "$VALUE" != "null" ]; then
          printf "%s" "$VALUE"
          exit 0
        fi
      fi
      printf "%s" "Ephemeral PKI"
  SUB_CA_BASE_URL:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        DOMAIN=$(jq -r '.domain // ""' "{{.SUB_CA_CONFIG_FILE}}")
        if [ -n "$DOMAIN" ] && [ "$DOMAIN" != "null" ]; then
          case "$DOMAIN" in
            http://*|https://*) printf "%s" "$DOMAIN" ;;
            *) printf "https://%s" "$DOMAIN" ;;
          esac
          exit 0
        fi
      fi
      printf "%s" "{{.BAO_ADDR}}"
  SUB_CA_CERT_FILE: "{{.SECRETS_DIR}}/sub-ca.pem"
  SUB_CA_CERT_BASENAME:
    sh: basename "{{.SUB_CA_CERT_FILE}}"

env:
  BAO_ADDR: "{{.BAO_ADDR}}"

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  init:
    desc: Generate age encryption key
    cmds:
      - |
        if [ -f "{{.AGE_KEY_FILE}}" ]; then
          echo "Age key already exists at {{.AGE_KEY_FILE}}"
          echo "Delete it first if you want to regenerate"
          exit 1
        fi
        age-keygen -o "{{.AGE_KEY_FILE}}"
        chmod 600 "{{.AGE_KEY_FILE}}"
        echo "Age key generated at {{.AGE_KEY_FILE}}"
        echo "⚠️  IMPORTANT: Back up this key securely! It is required to decrypt secrets."
        echo "⚠️  This file is gitignored and should NEVER be committed."
    status:
      - test -f "{{.AGE_KEY_FILE}}"

  start:
    desc: Decrypt secrets and start OpenBao
    deps: [decrypt-secrets]
    cmds:
      - docker compose up -d
      - echo "Waiting for OpenBao to be ready..."
      - |
        for i in $(seq 1 30); do
          if curl -s "{{.BAO_ADDR}}/v1/sys/health" > /dev/null 2>&1; then
            echo "OpenBao is ready"
            break
          fi
          echo "Waiting... ($i/30)"
          sleep 1
        done
      - task: unseal
    preconditions:
      - sh: test -f "{{.AGE_KEY_FILE}}"
        msg: "Age key not found. Run 'task init' first."

  stop:
    desc: Seal OpenBao and encrypt all secrets
    cmds:
      - task: seal
      - task: encrypt-secrets
      - docker compose down
      - echo "OpenBao stopped and secrets encrypted"

  setup-root-ca:
    desc: Initialize OpenBao and setup root CA
    cmds:
      - task: initialize
      - task: unseal
      - task: enable-pki
      - task: generate-root-ca
      - echo "Root CA setup complete!"

  # Internal tasks for setup-root-ca
  initialize:
    desc: Initialize OpenBao (creates unseal keys and root token)
    internal: false
    cmds:
      - |
        mkdir -p "{{.SECRETS_DIR}}"
        
        # Check if already initialized
        STATUS=$(curl -s "{{.BAO_ADDR}}/v1/sys/health" || echo '{"initialized":false}')
        INITIALIZED=$(echo "$STATUS" | jq -r '.initialized // false')
        
        if [ "$INITIALIZED" = "true" ]; then
          echo "OpenBao is already initialized"
          exit 0
        fi
        
        echo "Initializing OpenBao..."
        INIT_RESPONSE=$(curl -s -X PUT "{{.BAO_ADDR}}/v1/sys/init" \
          -H "Content-Type: application/json" \
          -d '{"secret_shares": 1, "secret_threshold": 1}')
        
        echo "$INIT_RESPONSE" > "{{.SECRETS_DIR}}/init.json"
        chmod 600 "{{.SECRETS_DIR}}/init.json"
        
        echo "OpenBao initialized. Unseal key and root token saved to {{.SECRETS_DIR}}/init.json"
    status:
      - test -f "{{.SECRETS_DIR}}/init.json"

  unseal:
    desc: Unseal OpenBao
    internal: false
    cmds:
      - |
        # Check if sealed
        STATUS=$(curl -s "{{.BAO_ADDR}}/v1/sys/health" || echo '{"sealed":true}')
        SEALED=$(echo "$STATUS" | jq -r '.sealed // true')
        
        if [ "$SEALED" = "false" ]; then
          echo "OpenBao is already unsealed"
          exit 0
        fi
        
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. OpenBao may not be initialized."
          exit 1
        fi
        
        UNSEAL_KEY=$(jq -r '.keys[0]' "{{.SECRETS_DIR}}/init.json")
        
        echo "Unsealing OpenBao..."
        curl -s -X PUT "{{.BAO_ADDR}}/v1/sys/unseal" \
          -H "Content-Type: application/json" \
          -d "{\"key\": \"$UNSEAL_KEY\"}" > /dev/null
        
        echo "OpenBao unsealed"

  seal:
    desc: Seal OpenBao
    internal: false
    cmds:
      - |
        # Check if already sealed
        STATUS=$(curl -s "{{.BAO_ADDR}}/v1/sys/health" || echo '{"sealed":true}')
        SEALED=$(echo "$STATUS" | jq -r '.sealed // true')
        
        if [ "$SEALED" = "true" ]; then
          echo "OpenBao is already sealed"
          exit 0
        fi
        
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found"
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        
        echo "Sealing OpenBao..."
        curl -s -X PUT "{{.BAO_ADDR}}/v1/sys/seal" \
          -H "X-Vault-Token: $ROOT_TOKEN" > /dev/null
        
        echo "OpenBao sealed"

  enable-pki:
    desc: Enable PKI secrets engine
    internal: false
    cmds:
      - |
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task initialize' first."
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        
        # Check if PKI is already enabled
        MOUNTS=$(curl -s "{{.BAO_ADDR}}/v1/sys/mounts" \
          -H "X-Vault-Token: $ROOT_TOKEN")
        
        if echo "$MOUNTS" | jq -e '.["pki/"]' > /dev/null 2>&1; then
          echo "PKI secrets engine already enabled"
          exit 0
        fi
        
        echo "Enabling PKI secrets engine..."
        curl -s -X POST "{{.BAO_ADDR}}/v1/sys/mounts/pki" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"type": "pki"}' > /dev/null
        
        # Tune PKI engine for long TTL
        curl -s -X POST "{{.BAO_ADDR}}/v1/sys/mounts/pki/tune" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"max_lease_ttl": "{{.ROOT_CA_TTL}}"}' > /dev/null
        
        echo "PKI secrets engine enabled"

  generate-root-ca:
    desc: Generate root CA certificate
    internal: false
    cmds:
      - |
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task initialize' first."
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        
        echo "Generating root CA certificate..."
        RESPONSE=$(curl -s -X POST "{{.BAO_ADDR}}/v1/pki/root/generate/internal" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{
            "common_name": "{{.ROOT_CA_CN}}",
            "organization": "{{.ROOT_CA_ORG}}",
            "ttl": "{{.ROOT_CA_TTL}}",
            "key_type": "ec",
            "key_bits": 384
          }')
        
        # Extract and save root certificate
        echo "$RESPONSE" | jq -r '.data.certificate' > "{{.SECRETS_DIR}}/root-ca.pem"
        
        # Configure CRL and issuing URLs
        curl -s -X POST "{{.BAO_ADDR}}/v1/pki/config/urls" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{
            "issuing_certificates": "{{.ROOT_CA_BASE_URL}}/v1/pki/ca",
            "crl_distribution_points": "{{.ROOT_CA_BASE_URL}}/v1/pki/crl"
          }' > /dev/null
        
        echo "Root CA certificate generated and saved to {{.SECRETS_DIR}}/root-ca.pem"
        echo "Certificate details:"
        openssl x509 -in "{{.SECRETS_DIR}}/root-ca.pem" -text -noout | head -20

  generate-sub-ca:
    desc: Generate subordinate/issuing CA signed by the root CA
    cmds:
      - task: unseal
      - |
        if [ ! -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
          echo "Configuration not found at {{.SUB_CA_CONFIG_FILE}}"
          exit 1
        fi

        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task setup-root-ca' first."
          exit 1
        fi

        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        if [ -z "$ROOT_TOKEN" ] || [ "$ROOT_TOKEN" = "null" ]; then
          echo "Failed to retrieve root token from {{.SECRETS_DIR}}/init.json"
          exit 1
        fi

        MOUNT="{{.SUB_CA_MOUNT}}"
        echo "Using PKI mount: $MOUNT"

        MOUNTS=$(curl -s "{{.BAO_ADDR}}/v1/sys/mounts" -H "X-Vault-Token: $ROOT_TOKEN")
        if echo "$MOUNTS" | jq -e --arg path "$MOUNT/" '.[$path]' > /dev/null 2>&1; then
          echo "PKI secrets engine at $MOUNT already enabled"
        else
          echo "Enabling PKI secrets engine at $MOUNT..."
          curl -s -X POST "{{.BAO_ADDR}}/v1/sys/mounts/$MOUNT" \
            -H "X-Vault-Token: $ROOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"type":"pki"}' > /dev/null
        fi

        echo "Tuning $MOUNT to max TTL {{.SUB_CA_TTL}}..."
        curl -s -X POST "{{.BAO_ADDR}}/v1/sys/mounts/$MOUNT/tune" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n --arg ttl "{{.SUB_CA_TTL}}" '{max_lease_ttl: $ttl}')" > /dev/null

        echo "Generating intermediate CSR..."
        CSR_RESPONSE=$(curl -s -X POST "{{.BAO_ADDR}}/v1/$MOUNT/intermediate/generate/internal" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg cn "{{.SUB_CA_CN}}" \
            --arg org "{{.SUB_CA_ORG}}" \
            --arg ttl "{{.SUB_CA_TTL}}" \
            --arg key_type "ec" \
            --argjson key_bits 384 \
            '{common_name: $cn, ttl: $ttl, key_type: $key_type, key_bits: $key_bits} + (if $org == "" then {} else {organization: $org} end)')")

        CSR=$(echo "$CSR_RESPONSE" | jq -r '.data.csr // empty')
        if [ -z "$CSR" ]; then
          echo "Failed to generate intermediate CSR:"
          echo "$CSR_RESPONSE" | jq .
          exit 1
        fi

        echo "Signing intermediate with root CA..."
        SIGN_RESPONSE=$(curl -s -X POST "{{.BAO_ADDR}}/v1/pki/root/sign-intermediate" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg csr "$CSR" \
            --arg ttl "{{.SUB_CA_TTL}}" \
            --arg format "pem_bundle" \
            '{csr: $csr, ttl: $ttl, format: $format}')")

        if echo "$SIGN_RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
          echo "Error signing intermediate:"
          echo "$SIGN_RESPONSE" | jq '.errors'
          exit 1
        fi

        CERT=$(echo "$SIGN_RESPONSE" | jq -r '.data.certificate // empty')
        if [ -z "$CERT" ]; then
          echo "No signed certificate returned."
          echo "$SIGN_RESPONSE" | jq .
          exit 1
        fi

        echo "Publishing signed certificate to $MOUNT..."
        curl -s -X POST "{{.BAO_ADDR}}/v1/$MOUNT/intermediate/set-signed" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n --arg cert "$CERT" '{certificate: $cert}')" > /dev/null

        mkdir -p "{{.SECRETS_DIR}}"
        CHAIN_OUTPUT=$(echo "$SIGN_RESPONSE" | jq -r '.data.ca_chain // [] | .[]')
        {
          printf '%s\n' "$CERT"
          if [ -n "$CHAIN_OUTPUT" ]; then
            printf '%s\n' "$CHAIN_OUTPUT"
          fi
        } > "{{.SUB_CA_CERT_FILE}}"

        if command -v openssl > /dev/null 2>&1; then
          echo "Subordinate certificate summary:"
          openssl x509 -in "{{.SUB_CA_CERT_FILE}}" -text -noout | head -20
        fi

        echo "Configuring issuing and CRL URLs..."
        curl -s -X POST "{{.BAO_ADDR}}/v1/$MOUNT/config/urls" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg issuing "{{.SUB_CA_BASE_URL}}/v1/$MOUNT/ca" \
            --arg crl "{{.SUB_CA_BASE_URL}}/v1/$MOUNT/crl" \
            '{issuing_certificates: $issuing, crl_distribution_points: $crl}')" > /dev/null

        echo "Subordinate CA certificate saved to {{.SUB_CA_CERT_FILE}}"
        echo "Subordinate CA setup complete."

  sign-intermediate:
    desc: Sign an intermediate CA CSR
    cmds:
      - |
        if [ -z "{{.CSR_FILE}}" ]; then
          echo "Usage: task sign-intermediate CSR_FILE=path/to/csr.pem"
          exit 1
        fi
        
        if [ ! -f "{{.CSR_FILE}}" ]; then
          echo "CSR file not found: {{.CSR_FILE}}"
          exit 1
        fi
        
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task setup-root-ca' first."
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        CSR_CONTENT=$(cat "{{.CSR_FILE}}")
        OUTPUT_FILE="${{.CSR_FILE}%.csr}.pem"
        
        echo "Signing intermediate CA CSR..."
        RESPONSE=$(curl -s -X POST "{{.BAO_ADDR}}/v1/pki/root/sign-intermediate" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "{
            \"csr\": $(echo "$CSR_CONTENT" | jq -Rs .),
            \"format\": \"pem_bundle\",
            \"ttl\": \"43800h\"
          }")
        
        # Check for errors
        if echo "$RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
          echo "Error signing CSR:"
          echo "$RESPONSE" | jq '.errors'
          exit 1
        fi
        
        echo "$RESPONSE" | jq -r '.data.certificate' > "$OUTPUT_FILE"
        echo "Signed certificate saved to: $OUTPUT_FILE"
    vars:
      CSR_FILE: '{{.CSR_FILE | default ""}}'

  update-crl:
    desc: Rotate/update the Certificate Revocation List
    cmds:
      - |
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task setup-root-ca' first."
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        
        echo "Rotating CRL..."
        curl -s -X GET "{{.BAO_ADDR}}/v1/pki/crl/rotate" \
          -H "X-Vault-Token: $ROOT_TOKEN" > /dev/null
        
        # Fetch and save current CRL
        curl -s "{{.BAO_ADDR}}/v1/pki/crl/pem" > "{{.SECRETS_DIR}}/crl.pem"
        
        echo "CRL updated and saved to {{.SECRETS_DIR}}/crl.pem"

  encrypt-secrets:
    desc: Encrypt all secrets with age
    cmds:
      - |
        if [ ! -f "{{.AGE_KEY_FILE}}" ]; then
          echo "Age key not found. Run 'task init' first."
          exit 1
        fi
        
        AGE_RECIPIENT=$(grep 'public key:' "{{.AGE_KEY_FILE}}" | sed 's/.*public key: //')
        mkdir -p "{{.ENCRYPTED_DIR}}"
        
        # Encrypt init.json if it exists
        if [ -f "{{.SECRETS_DIR}}/init.json" ]; then
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/init.json.age" "{{.SECRETS_DIR}}/init.json"
          echo "Encrypted init.json"
        fi
        
        # Encrypt root-ca.pem if it exists
        if [ -f "{{.SECRETS_DIR}}/root-ca.pem" ]; then
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/root-ca.pem.age" "{{.SECRETS_DIR}}/root-ca.pem"
          echo "Encrypted root-ca.pem"
        fi
        
        # Encrypt CRL if it exists
        if [ -f "{{.SECRETS_DIR}}/crl.pem" ]; then
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/crl.pem.age" "{{.SECRETS_DIR}}/crl.pem"
          echo "Encrypted crl.pem"
        fi

        if [ -f "{{.SUB_CA_CERT_FILE}}" ]; then
          BASENAME="{{.SUB_CA_CERT_BASENAME}}"
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/${BASENAME}.age" "{{.SUB_CA_CERT_FILE}}"
          echo "Encrypted $BASENAME"
        fi
        
        echo "All secrets encrypted to {{.ENCRYPTED_DIR}}/"

  decrypt-secrets:
    desc: Decrypt all secrets from age
    cmds:
      - |
        if [ ! -f "{{.AGE_KEY_FILE}}" ]; then
          echo "Age key not found. Cannot decrypt secrets."
          exit 1
        fi
        
        mkdir -p "{{.SECRETS_DIR}}"
        
        # Decrypt init.json if it exists
        if [ -f "{{.ENCRYPTED_DIR}}/init.json.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.SECRETS_DIR}}/init.json" "{{.ENCRYPTED_DIR}}/init.json.age"
          chmod 600 "{{.SECRETS_DIR}}/init.json"
          echo "Decrypted init.json"
        fi
        
        # Decrypt root-ca.pem if it exists
        if [ -f "{{.ENCRYPTED_DIR}}/root-ca.pem.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.SECRETS_DIR}}/root-ca.pem" "{{.ENCRYPTED_DIR}}/root-ca.pem.age"
          echo "Decrypted root-ca.pem"
        fi
        
        # Decrypt CRL if it exists
        if [ -f "{{.ENCRYPTED_DIR}}/crl.pem.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.SECRETS_DIR}}/crl.pem" "{{.ENCRYPTED_DIR}}/crl.pem.age"
          echo "Decrypted crl.pem"
        fi

        BASENAME="{{.SUB_CA_CERT_BASENAME}}"
        if [ -f "{{.ENCRYPTED_DIR}}/${BASENAME}.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.SUB_CA_CERT_FILE}}" "{{.ENCRYPTED_DIR}}/${BASENAME}.age"
          echo "Decrypted $BASENAME"
        fi
        
        echo "Secrets decrypted to {{.SECRETS_DIR}}/"
    status:
      - test -f "{{.SECRETS_DIR}}/init.json"

  clean:
    desc: Remove all unencrypted secrets and data (DANGEROUS)
    prompt: This will delete all unencrypted secrets and OpenBao data. Are you sure?
    cmds:
      - rm -rf "{{.SECRETS_DIR}}"
      - rm -rf data/
      - echo "Cleaned unencrypted secrets and data"

  status:
    desc: Show OpenBao status
    cmds:
      - |
        echo "OpenBao Status:"
        curl -s "{{.BAO_ADDR}}/v1/sys/health" | jq . 2>/dev/null || echo "OpenBao is not reachable"
