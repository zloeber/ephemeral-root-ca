# Ephemeral Root CA Taskfile
# https://taskfile.dev

version: '3'
silent: true
vars:
  AGE_KEY_FILE: age.key
  SECRETS_DIR: secrets
  ENCRYPTED_DIR: encrypted
  BAO_ADDR: http://127.0.0.1:8200
  ROOT_CA_CONFIG_FILE: config/root-ca.json
  # Root CA configuration
  ROOT_CA_TTL: "87600h"  # 10 years
  ROOT_CA_CN:
    sh: |
      if [ -f "{{.ROOT_CA_CONFIG_FILE}}" ]; then
        jq -r '.name // "Ephemeral Root CA"' "{{.ROOT_CA_CONFIG_FILE}}"
      else
        echo "Ephemeral Root CA"
      fi
  ROOT_CA_ORG:
    sh: |
      if [ -f "{{.ROOT_CA_CONFIG_FILE}}" ]; then
        jq -r '.organization // "Ephemeral PKI"' "{{.ROOT_CA_CONFIG_FILE}}"
      else
        echo "Ephemeral PKI"
      fi
  ROOT_CA_BASE_URL:
    sh: |
      if [ -f "{{.ROOT_CA_CONFIG_FILE}}" ]; then
        DOMAIN=$(jq -r '.domain // ""' "{{.ROOT_CA_CONFIG_FILE}}")
        if [ -n "$DOMAIN" ] && [ "$DOMAIN" != "null" ]; then
          case "$DOMAIN" in
            http://*|https://*) printf "%s" "$DOMAIN" ;;
            *) printf "https://%s" "$DOMAIN" ;;
          esac
          exit 0
        fi
      fi
      printf "%s" "{{.BAO_ADDR}}"
  ROOT_CA_CRL_URL:
    sh: |
      if [ -f "{{.ROOT_CA_CONFIG_FILE}}" ]; then
        VALUE=$(jq -r '.crl_base_url // ""' "{{.ROOT_CA_CONFIG_FILE}}")
        if [ -n "$VALUE" ] && [ "$VALUE" != "null" ]; then
          case "$VALUE" in
            http://*|https://*) printf "%s" "$VALUE" ;;
            *) printf "https://%s" "$VALUE" ;;
          esac
          exit 0
        fi
      fi
      printf "%s" "{{.ROOT_CA_BASE_URL}}"
  ROOT_CA_CERT_FILE: "{{.SECRETS_DIR}}/root-ca.pem"
  ROOT_CA_KEY_FILE: "{{.SECRETS_DIR}}/root-ca.key"
  SUB_CA_CONFIG_FILE: config/sub-ca.json
  SUB_CA_MOUNT:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        VALUE=$(jq -r '.mount // ""' "{{.SUB_CA_CONFIG_FILE}}")
        if [ -n "$VALUE" ] && [ "$VALUE" != "null" ]; then
          printf "%s" "$VALUE"
          exit 0
        fi
      fi
      printf "%s" "pki_int"
  SUB_CA_TTL:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        VALUE=$(jq -r '.ttl // ""' "{{.SUB_CA_CONFIG_FILE}}")
        if [ -n "$VALUE" ] && [ "$VALUE" != "null" ]; then
          printf "%s" "$VALUE"
          exit 0
        fi
      fi
      printf "%s" "43800h"
  SUB_CA_CN:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        jq -r '.name // "Ephemeral Issuing CA"' "{{.SUB_CA_CONFIG_FILE}}"
      else
        echo "Ephemeral Issuing CA"
      fi
  SUB_CA_ORG:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        VALUE=$(jq -r '.organization // ""' "{{.SUB_CA_CONFIG_FILE}}")
        if [ -n "$VALUE" ] && [ "$VALUE" != "null" ]; then
          printf "%s" "$VALUE"
          exit 0
        fi
      fi
      printf "%s" "Ephemeral PKI"
  SUB_CA_BASE_URL:
    sh: |
      if [ -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
        DOMAIN=$(jq -r '.domain // ""' "{{.SUB_CA_CONFIG_FILE}}")
        if [ -n "$DOMAIN" ] && [ "$DOMAIN" != "null" ]; then
          case "$DOMAIN" in
            http://*|https://*) printf "%s" "$DOMAIN" ;;
            *) printf "https://%s" "$DOMAIN" ;;
          esac
          exit 0
        fi
      fi
      printf "%s" "{{.BAO_ADDR}}"
  SUB_CA_CERT_FILE: "{{.SECRETS_DIR}}/sub-ca.pem"
  SUB_CA_CERT_BASENAME:
    sh: basename "{{.SUB_CA_CERT_FILE}}"
  SUB_CA_KEY_FILE: "{{.SECRETS_DIR}}/sub-ca.key"

env:
  BAO_ADDR: "{{.BAO_ADDR}}"

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  age-init:
    desc: Generate age encryption key
    cmds:
      - |
        if [ -f "{{.AGE_KEY_FILE}}" ]; then
          echo "Age key already exists at {{.AGE_KEY_FILE}}"
          echo "Delete it first if you want to regenerate"
          exit 1
        fi
        age-keygen -o "{{.AGE_KEY_FILE}}"
        chmod 600 "{{.AGE_KEY_FILE}}"
        echo "Age key generated at {{.AGE_KEY_FILE}}"
        echo "⚠️  IMPORTANT: Back up this key securely! It is required to decrypt secrets."
        echo "⚠️  This file is gitignored and should NEVER be committed."
    status:
      - test -f "{{.AGE_KEY_FILE}}"

  run:
    desc: Run OpenBao container
    cmds:
      - task: age-init
      - |
        # Check if OpenBao is already running
        if curl -s "{{.BAO_ADDR}}/v1/sys/health" > /dev/null 2>&1; then
          echo "OpenBao is already running"
          exit 0
        fi
        
        docker compose up -d
        sleep 3
        echo "Waiting for OpenBao to be ready..."
        for i in $(seq 1 30); do
          if curl -s "{{.BAO_ADDR}}/v1/sys/health" > /dev/null 2>&1; then
            echo "OpenBao is ready"
            break
          fi
          echo "Waiting... ($i/30)"
          sleep 1
        done

  start:
    desc: Decrypt secrets and start OpenBao
    cmds:
    - task: age-init
    - task: run
    - task: decrypt-secrets


  stop:
    desc: Seal OpenBao and encrypt all secrets
    cmds:
      - task: seal
      - task: encrypt-secrets
      - docker compose down
      - echo "OpenBao stopped and secrets encrypted"

  setup-pki:
    desc: Setup OpenBao with PKI
    cmds:
      - task: initialize
      - task: unseal
      - task: enable-pki
      - echo "OpenBao and PKI setup complete!"

  setup-root-ca:
    desc: Initialize OpenBao and setup root CA
    cmds:
      - task: setup-pki
      - task: generate-root-ca
      - echo "Root CA setup complete!"
    status:
      - test -f "{{.ROOT_CA_KEY_FILE}}"
      # - test -f "{{.ENCRYPTED_DIR}}/init.json.age"
      # - test -f "{{.ENCRYPTED_DIR}}/root-ca.pem.age"
      # - test -f "{{.ENCRYPTED_DIR}}/root-ca.key.age"

  # Internal tasks for setup-root-ca
  initialize:
    desc: Initialize OpenBao (creates unseal keys and root token)
    internal: false
    cmds:
      - |
        mkdir -p "{{.SECRETS_DIR}}"
        
        # Check if already initialized
        STATUS=$(curl -s "{{.BAO_ADDR}}/v1/sys/health" || echo '{"initialized":false}')
        INITIALIZED=$(echo "$STATUS" | jq -r '.initialized // false')
        
        if [ "$INITIALIZED" = "true" ]; then
          echo "OpenBao is already initialized"
          exit 0
        fi
        
        echo "Initializing OpenBao..."
        INIT_RESPONSE=$(curl -s -X PUT "{{.BAO_ADDR}}/v1/sys/init" \
          -H "Content-Type: application/json" \
          -d '{"secret_shares": 1, "secret_threshold": 1}')
        
        echo "$INIT_RESPONSE" > "{{.SECRETS_DIR}}/init.json"
        chmod 600 "{{.SECRETS_DIR}}/init.json"
        
        echo "OpenBao initialized. Unseal key and root token saved to {{.SECRETS_DIR}}/init.json"
    # status:
    #   - test -f "{{.SECRETS_DIR}}/init.json"

  unseal:
    desc: Unseal OpenBao
    internal: false
    cmds:
      - |
        # Check if sealed
        STATUS=$(curl -s "{{.BAO_ADDR}}/v1/sys/health" || echo '{"sealed":true}')
        SEALED=$(echo "$STATUS" | jq -r '.sealed // true')
        
        if [ "$SEALED" = "false" ]; then
          echo "OpenBao is already unsealed"
          exit 0
        fi
        
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. OpenBao may not be initialized."
          exit 1
        fi
        
        UNSEAL_KEY=$(jq -r '.keys[0]' "{{.SECRETS_DIR}}/init.json")
        
        echo "Unsealing OpenBao..."
        curl -s -X PUT "{{.BAO_ADDR}}/v1/sys/unseal" \
          -H "Content-Type: application/json" \
          -d "{\"key\": \"$UNSEAL_KEY\"}" > /dev/null
        
        echo "OpenBao unsealed"

  seal:
    desc: Seal OpenBao
    internal: false
    cmds:
      - |
        # Check if already sealed
        STATUS=$(curl -s "{{.BAO_ADDR}}/v1/sys/health" || echo '{"sealed":true}')
        SEALED=$(echo "$STATUS" | jq -r '.sealed // true')
        
        if [ "$SEALED" = "true" ]; then
          echo "OpenBao is already sealed"
          exit 0
        fi
        
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found"
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        
        echo "Sealing OpenBao..."
        curl -s -X PUT "{{.BAO_ADDR}}/v1/sys/seal" \
          -H "X-Vault-Token: $ROOT_TOKEN" > /dev/null
        
        echo "OpenBao sealed"

  enable-pki:
    desc: Enable PKI secrets engine
    internal: false
    cmds:
      - |
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task initialize' first."
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        
        # Check if PKI is already enabled
        MOUNTS=$(curl -s "{{.BAO_ADDR}}/v1/sys/mounts" \
          -H "X-Vault-Token: $ROOT_TOKEN")
        
        if echo "$MOUNTS" | jq -e '.["pki/"]' > /dev/null 2>&1; then
          echo "PKI secrets engine already enabled"
          exit 0
        fi
        
        echo "Enabling PKI secrets engine..."
        curl -s -X POST "{{.BAO_ADDR}}/v1/sys/mounts/pki" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"type": "pki"}' > /dev/null
        
        # Tune PKI engine for long TTL
        curl -s -X POST "{{.BAO_ADDR}}/v1/sys/mounts/pki/tune" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"max_lease_ttl": "{{.ROOT_CA_TTL}}"}' > /dev/null
        
        echo "PKI secrets engine enabled"
    preconditions:
      - sh: test -f "{{.SECRETS_DIR}}/init.json"
        msg: "No init.json found. Run 'task initialize' first."
    status:
      - |
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        MOUNTS=$(curl -s "{{.BAO_ADDR}}/v1/sys/mounts" -H "X-Vault-Token: $ROOT_TOKEN")
        echo "$MOUNTS" | jq -e '.["pki/"]' > /dev/null 2>&1

  generate-root-ca:
    desc: Generate root CA certificate
    internal: false
    deps: [enable-pki]
    cmds:
      - |
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task initialize' first."
          exit 1
        fi
        
        if ! command -v openssl > /dev/null 2>&1; then
          echo "OpenSSL is required to generate the root CA material."
          exit 1
        fi

        mkdir -p "{{.SECRETS_DIR}}"

        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        KEY_FILE="{{.ROOT_CA_KEY_FILE}}"
        CERT_FILE="{{.ROOT_CA_CERT_FILE}}"
        TTL_INPUT="{{.ROOT_CA_TTL}}"
        TMP_CFG=""
        BUNDLE_FILE=""

        cleanup() {
          if [ -n "$TMP_CFG" ] && [ -f "$TMP_CFG" ]; then rm -f "$TMP_CFG"; fi
          if [ -n "$BUNDLE_FILE" ] && [ -f "$BUNDLE_FILE" ]; then rm -f "$BUNDLE_FILE"; fi
        }
        trap cleanup EXIT

        DAYS=3650
        if echo "$TTL_INPUT" | grep -Eq '^[0-9]+h$'; then
          HOURS=${TTL_INPUT%h}
          if [ "$HOURS" -le 0 ]; then
            DAYS=1
          else
            DAYS=$(( (HOURS + 23) / 24 ))
          fi
        elif echo "$TTL_INPUT" | grep -Eq '^[0-9]+d$'; then
          DAYS=${TTL_INPUT%d}
        elif echo "$TTL_INPUT" | grep -Eq '^[0-9]+$'; then
          HOURS=$TTL_INPUT
          DAYS=$(( (HOURS + 23) / 24 ))
        fi

        if [ ! -f "$KEY_FILE" ]; then
          echo "Generating root CA private key at $KEY_FILE"
          openssl ecparam -name secp384r1 -genkey -noout -out "$KEY_FILE"
          chmod 600 "$KEY_FILE"
        else
          echo "Existing root CA private key found at $KEY_FILE"
        fi

        if [ ! -f "$CERT_FILE" ]; then
          echo "Creating self-signed root CA certificate at $CERT_FILE"
          TMP_CFG=$(mktemp)
          {
            echo "[ req ]"
            echo "distinguished_name = dn"
            echo "x509_extensions = v3_ca"
            echo "prompt = no"
            echo "default_md = sha384"
            echo
            echo "[ dn ]"
            echo "CN = {{.ROOT_CA_CN}}"
            if [ -n "{{.ROOT_CA_ORG}}" ]; then
              echo "O = {{.ROOT_CA_ORG}}"
            fi
            echo
            echo "[ v3_ca ]"
            echo "subjectKeyIdentifier = hash"
            echo "authorityKeyIdentifier = keyid:always,issuer"
            echo "basicConstraints = critical, CA:true"
            echo "keyUsage = critical, digitalSignature, cRLSign, keyCertSign"
          } > "$TMP_CFG"

          if ! openssl req -x509 -new -key "$KEY_FILE" -out "$CERT_FILE" \
            -days "$DAYS" -config "$TMP_CFG" -extensions v3_ca; then
            echo "Failed to generate root CA certificate"
            exit 1
          fi

          rm -f "$TMP_CFG"
          TMP_CFG=""
        else
          echo "Existing root CA certificate found at $CERT_FILE"
        fi

        BUNDLE_FILE=$(mktemp)
        cat "$CERT_FILE" "$KEY_FILE" > "$BUNDLE_FILE"

        echo "Uploading root CA material to OpenBao..."
        PAYLOAD=$(jq -Rs '{pem_bundle: .}' "$BUNDLE_FILE")
        HTTP_STATUS=$(curl -s -o /dev/null -w '%{http_code}' "{{.BAO_ADDR}}/v1/pki/config/ca" \
          -X POST \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$PAYLOAD")

        if [ "${HTTP_STATUS#0}" -lt 200 ] || [ "${HTTP_STATUS#0}" -ge 300 ]; then
          echo "Failed to upload root CA bundle (HTTP $HTTP_STATUS)"
          exit 1
        fi

        rm -f "$BUNDLE_FILE"
        BUNDLE_FILE=""

        if command -v openssl > /dev/null 2>&1; then
          echo "Root certificate summary:"
          openssl x509 -in "$CERT_FILE" -text -noout | head -20
        fi

        echo "Root CA certificate and key stored at $CERT_FILE / $KEY_FILE"

        # Configure CRL and issuing URLs
        curl -s -X POST "{{.BAO_ADDR}}/v1/pki/config/urls" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg issuing "{{.ROOT_CA_BASE_URL}}/v1/pki/ca" \
            --arg crl "{{.ROOT_CA_CRL_URL}}/v1/pki/crl" \
            '{issuing_certificates: $issuing, crl_distribution_points: $crl}')" > /dev/null
        
        echo "Root CA material uploaded and OpenBao URLs configured"

        trap - EXIT
    status:
      - test -f "{{.ROOT_CA_KEY_FILE}}"
      - test -f "{{.ROOT_CA_CERT_FILE}}"

  load-root-ca:
    desc: Load existing root CA material into OpenBao
    cmds:
      - task: run
      - task: unseal
      - task: enable-pki
      - |
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task initialize' first."
          exit 1
        fi

        if [ ! -f "{{.ROOT_CA_CERT_FILE}}" ]; then
          echo "Root CA certificate not found at {{.ROOT_CA_CERT_FILE}}"
          exit 1
        fi

        if [ ! -f "{{.ROOT_CA_KEY_FILE}}" ]; then
          echo "Root CA private key not found at {{.ROOT_CA_KEY_FILE}}"
          exit 1
        fi

        if ! command -v openssl > /dev/null 2>&1; then
          echo "OpenSSL is required to load the root CA."
          exit 1
        fi

        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        if [ -z "$ROOT_TOKEN" ] || [ "$ROOT_TOKEN" = "null" ]; then
          echo "Failed to retrieve root token from {{.SECRETS_DIR}}/init.json"
          exit 1
        fi

        LOCAL_FP=$(openssl x509 -in "{{.ROOT_CA_CERT_FILE}}" -noout -fingerprint -sha256 2>/dev/null)
        if [ -z "$LOCAL_FP" ]; then
          echo "Unable to compute fingerprint for {{.ROOT_CA_CERT_FILE}}"
          exit 1
        fi

        REMOTE_CERT=$(curl -s "{{.BAO_ADDR}}/v1/pki/cert/ca" -H "X-Vault-Token: $ROOT_TOKEN" | jq -r '.data.certificate // empty')
        REMOTE_FP=""
        if [ -n "$REMOTE_CERT" ]; then
          REMOTE_FP=$(printf '%s\n' "$REMOTE_CERT" | openssl x509 -noout -fingerprint -sha256 2>/dev/null || echo "")
        fi

        if [ -n "$REMOTE_FP" ] && [ "$REMOTE_FP" = "$LOCAL_FP" ]; then
          echo "Root CA already loaded in OpenBao."
        else
          echo "Uploading root CA material to OpenBao..."
          BUNDLE_FILE=$(mktemp)
          cleanup_bundle() {
            if [ -f "$BUNDLE_FILE" ]; then rm -f "$BUNDLE_FILE"; fi
          }
          trap cleanup_bundle EXIT

          cat "{{.ROOT_CA_CERT_FILE}}" "{{.ROOT_CA_KEY_FILE}}" > "$BUNDLE_FILE"

          PAYLOAD=$(jq -Rs '{pem_bundle: .}' "$BUNDLE_FILE")
          HTTP_STATUS=$(curl -s -o /dev/null -w '%{http_code}' "{{.BAO_ADDR}}/v1/pki/config/ca" \
            -X POST \
            -H "X-Vault-Token: $ROOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          if [ "${HTTP_STATUS#0}" -lt 200 ] || [ "${HTTP_STATUS#0}" -ge 300 ]; then
            echo "Failed to upload root CA bundle (HTTP $HTTP_STATUS)"
            exit 1
          fi

          cleanup_bundle
          trap - EXIT

          echo "Root CA bundle uploaded."
        fi

        echo "Ensuring issuing and CRL URLs are configured..."
        curl -s -X POST "{{.BAO_ADDR}}/v1/pki/config/urls" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg issuing "{{.ROOT_CA_BASE_URL}}/v1/pki/ca" \
            --arg crl "{{.ROOT_CA_CRL_URL}}/v1/pki/crl" \
            '{issuing_certificates: $issuing, crl_distribution_points: $crl}')" > /dev/null

        echo "Root CA configuration synchronized."
    preconditions:
      - sh: test -f "{{.ROOT_CA_CERT_FILE}}"
        msg: "Root CA certificate not found. Provide it at {{.ROOT_CA_CERT_FILE}}"
      - sh: test -f "{{.ROOT_CA_KEY_FILE}}"
        msg: "Root CA private key not found. Provide it at {{.ROOT_CA_KEY_FILE}}"

  generate-sub-ca:
    desc: Generate subordinate/issuing CA signed by the root CA
    cmds:
      - task: unseal
      - |
        if [ ! -f "{{.SUB_CA_CONFIG_FILE}}" ]; then
          echo "Configuration not found at {{.SUB_CA_CONFIG_FILE}}"
          exit 1
        fi

        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task setup-root-ca' first."
          exit 1
        fi

        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        if [ -z "$ROOT_TOKEN" ] || [ "$ROOT_TOKEN" = "null" ]; then
          echo "Failed to retrieve root token from {{.SECRETS_DIR}}/init.json"
          exit 1
        fi

        MOUNT="{{.SUB_CA_MOUNT}}"
        echo "Using PKI mount: $MOUNT"

        MOUNTS=$(curl -s "{{.BAO_ADDR}}/v1/sys/mounts" -H "X-Vault-Token: $ROOT_TOKEN")
        if echo "$MOUNTS" | jq -e --arg path "$MOUNT/" '.[$path]' > /dev/null 2>&1; then
          echo "PKI secrets engine at $MOUNT already enabled"
        else
          echo "Enabling PKI secrets engine at $MOUNT..."
          curl -s -X POST "{{.BAO_ADDR}}/v1/sys/mounts/$MOUNT" \
            -H "X-Vault-Token: $ROOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"type":"pki"}' > /dev/null
        fi

        echo "Tuning $MOUNT to max TTL {{.SUB_CA_TTL}}..."
        curl -s -X POST "{{.BAO_ADDR}}/v1/sys/mounts/$MOUNT/tune" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n --arg ttl "{{.SUB_CA_TTL}}" '{max_lease_ttl: $ttl}')" > /dev/null

        echo "Generating intermediate CSR and private key..."
        CSR_RESPONSE=$(curl -s -X POST "{{.BAO_ADDR}}/v1/$MOUNT/intermediate/generate/exported" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg cn "{{.SUB_CA_CN}}" \
            --arg org "{{.SUB_CA_ORG}}" \
            --arg ttl "{{.SUB_CA_TTL}}" \
            --arg key_type "ec" \
            --argjson key_bits 384 \
            '{common_name: $cn, ttl: $ttl, key_type: $key_type, key_bits: $key_bits} + (if $org == "" then {} else {organization: $org} end)')")

        CSR=$(echo "$CSR_RESPONSE" | jq -r '.data.csr // empty')
        if [ -z "$CSR" ]; then
          echo "Failed to generate intermediate CSR:"
          echo "$CSR_RESPONSE" | jq .
          exit 1
        fi

        echo "Signing intermediate with root CA..."
        SIGN_RESPONSE=$(curl -s -X POST "{{.BAO_ADDR}}/v1/pki/root/sign-intermediate" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg csr "$CSR" \
            --arg ttl "{{.SUB_CA_TTL}}" \
            --arg format "pem_bundle" \
            '{csr: $csr, ttl: $ttl, format: $format}')")

        if echo "$SIGN_RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
          echo "Error signing intermediate:"
          echo "$SIGN_RESPONSE" | jq '.errors'
          exit 1
        fi

        CERT=$(echo "$SIGN_RESPONSE" | jq -r '.data.certificate // empty')
        if [ -z "$CERT" ]; then
          echo "No signed certificate returned."
          echo "$SIGN_RESPONSE" | jq .
          exit 1
        fi

        PRIVATE_KEY=$(echo "$CSR_RESPONSE" | jq -r '.data.private_key // empty')
        PRIVATE_KEY_TYPE=$(echo "$CSR_RESPONSE" | jq -r '.data.private_key_type // "ec"')
        PRIVATE_KEY_BITS=$(echo "$CSR_RESPONSE" | jq -r '.data.private_key_bits // empty')
        WRITE_KEY=1

        if [ -z "$PRIVATE_KEY" ]; then
          if [ -f "{{.SUB_CA_KEY_FILE}}" ]; then
            echo "CSR generation did not return a private key; reusing existing {{.SUB_CA_KEY_FILE}}"
            WRITE_KEY=0
          else
            echo "No private key returned in CSR generation response."
            exit 1
          fi
        fi

        echo "Publishing signed certificate to $MOUNT..."
        curl -s -X POST "{{.BAO_ADDR}}/v1/$MOUNT/intermediate/set-signed" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n --arg cert "$CERT" '{certificate: $cert}')" > /dev/null

        mkdir -p "{{.SECRETS_DIR}}"
        CHAIN_OUTPUT=$(echo "$SIGN_RESPONSE" | jq -r '.data.ca_chain // [] | .[]')
        {
          printf '%s\n' "$CERT"
          if [ -n "$CHAIN_OUTPUT" ]; then
            printf '%s\n' "$CHAIN_OUTPUT"
          fi
        } > "{{.SUB_CA_CERT_FILE}}"

        if [ "$WRITE_KEY" -eq 1 ]; then
          printf '%s\n' "$PRIVATE_KEY" > "{{.SUB_CA_KEY_FILE}}"
          chmod 600 "{{.SUB_CA_KEY_FILE}}"
        fi

        if [ -n "$PRIVATE_KEY" ] && [ "$PRIVATE_KEY_BITS" != "null" ] && [ -n "$PRIVATE_KEY_BITS" ]; then
          echo "Subordinate key type: $PRIVATE_KEY_TYPE ($PRIVATE_KEY_BITS bits)"
        elif [ -n "$PRIVATE_KEY" ]; then
          echo "Subordinate key type: $PRIVATE_KEY_TYPE"
        fi

        if command -v openssl > /dev/null 2>&1; then
          echo "Subordinate certificate summary:"
          openssl x509 -in "{{.SUB_CA_CERT_FILE}}" -text -noout | head -20
          echo "Subordinate key fingerprint:"
          openssl pkey -in "{{.SUB_CA_KEY_FILE}}" -pubout -outform PEM | openssl pkey -pubin -outform DER | openssl dgst -sha256
        fi

        echo "Configuring issuing and CRL URLs..."
        curl -s -X POST "{{.BAO_ADDR}}/v1/$MOUNT/config/urls" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg issuing "{{.SUB_CA_BASE_URL}}/v1/$MOUNT/ca" \
            --arg crl "{{.SUB_CA_BASE_URL}}/v1/$MOUNT/crl" \
            '{issuing_certificates: $issuing, crl_distribution_points: $crl}')" > /dev/null

        echo "Subordinate CA certificate saved to {{.SUB_CA_CERT_FILE}}"
        echo "Subordinate CA setup complete."
    status:
      - test -f "{{.SUB_CA_CERT_FILE}}"

  sign-intermediate:
    desc: Sign an intermediate CA CSR
    cmds:
      - |
        if [ -z "{{.CSR_FILE}}" ]; then
          echo "Usage: task sign-intermediate CSR_FILE=path/to/csr.pem"
          exit 1
        fi
        
        if [ ! -f "{{.CSR_FILE}}" ]; then
          echo "CSR file not found: {{.CSR_FILE}}"
          exit 1
        fi
        
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task setup-root-ca' first."
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        CSR_CONTENT=$(cat "{{.CSR_FILE}}")
        OUTPUT_FILE="${{.CSR_FILE}%.csr}.pem"
        
        echo "Signing intermediate CA CSR..."
        RESPONSE=$(curl -s -X POST "{{.BAO_ADDR}}/v1/pki/root/sign-intermediate" \
          -H "X-Vault-Token: $ROOT_TOKEN" \
          -H "Content-Type: application/json" \
          -d "{
            \"csr\": $(echo "$CSR_CONTENT" | jq -Rs .),
            \"format\": \"pem_bundle\",
            \"ttl\": \"43800h\"
          }")
        
        # Check for errors
        if echo "$RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
          echo "Error signing CSR:"
          echo "$RESPONSE" | jq '.errors'
          exit 1
        fi
        
        echo "$RESPONSE" | jq -r '.data.certificate' > "$OUTPUT_FILE"
        echo "Signed certificate saved to: $OUTPUT_FILE"
    vars:
      CSR_FILE: '{{.CSR_FILE | default ""}}'

  update-crl:
    desc: Rotate/update the Certificate Revocation List
    cmds:
      - |
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task setup-root-ca' first."
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        
        echo "Rotating CRL..."
        curl -s -X GET "{{.BAO_ADDR}}/v1/pki/crl/rotate" \
          -H "X-Vault-Token: $ROOT_TOKEN" > /dev/null
        
        # Fetch and save current CRL
        curl -s "{{.BAO_ADDR}}/v1/pki/crl/pem" > "{{.SECRETS_DIR}}/crl.pem"
        
        echo "CRL updated and saved to {{.SECRETS_DIR}}/crl.pem"

  encrypt-secrets:
    desc: Encrypt all secrets with age
    cmds:
      - |
        if [ ! -f "{{.AGE_KEY_FILE}}" ]; then
          echo "Age key not found. Run 'task init' first."
          exit 1
        fi
        
        AGE_RECIPIENT=$(grep 'public key:' "{{.AGE_KEY_FILE}}" | sed 's/.*public key: //')
        mkdir -p "{{.ENCRYPTED_DIR}}"
        
        # Encrypt init.json if it exists
        if [ -f "{{.SECRETS_DIR}}/init.json" ]; then
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/init.json.age" "{{.SECRETS_DIR}}/init.json"
          echo "Encrypted init.json"
        fi
        
        # Encrypt root-ca certificate bundle if it exists
        if [ -f "{{.ROOT_CA_CERT_FILE}}" ]; then
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/root-ca.pem.age" "{{.ROOT_CA_CERT_FILE}}"
          echo "Encrypted $(basename "{{.ROOT_CA_CERT_FILE}}")"
        fi

        # Encrypt root-ca private key if it exists
        if [ -f "{{.ROOT_CA_KEY_FILE}}" ]; then
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/root-ca.key.age" "{{.ROOT_CA_KEY_FILE}}"
          echo "Encrypted $(basename "{{.ROOT_CA_KEY_FILE}}")"
        fi
        
        # Encrypt CRL if it exists
        if [ -f "{{.SECRETS_DIR}}/crl.pem" ]; then
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/crl.pem.age" "{{.SECRETS_DIR}}/crl.pem"
          echo "Encrypted crl.pem"
        fi

        if [ -f "{{.SUB_CA_CERT_FILE}}" ]; then
          BASENAME="{{.SUB_CA_CERT_BASENAME}}"
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/${BASENAME}.age" "{{.SUB_CA_CERT_FILE}}"
          echo "Encrypted $BASENAME"
        fi

        if [ -f "{{.SUB_CA_KEY_FILE}}" ]; then
          age -r "$AGE_RECIPIENT" -o "{{.ENCRYPTED_DIR}}/sub-ca.key.age" "{{.SUB_CA_KEY_FILE}}"
          echo "Encrypted sub-ca.key"
        fi
        
        echo "All secrets encrypted to {{.ENCRYPTED_DIR}}/"

  decrypt-secrets:
    desc: Decrypt all secrets from age
    cmds:
      - |
        if [ ! -f "{{.AGE_KEY_FILE}}" ]; then
          echo "Age key not found. Cannot decrypt secrets."
          exit 1
        fi
        
        mkdir -p "{{.SECRETS_DIR}}"
        
        # Decrypt init.json if it exists
        if [ -f "{{.ENCRYPTED_DIR}}/init.json.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.SECRETS_DIR}}/init.json" "{{.ENCRYPTED_DIR}}/init.json.age"
          chmod 600 "{{.SECRETS_DIR}}/init.json"
          echo "Decrypted init.json"
        fi
        
        # Decrypt root-ca certificate bundle if it exists
        if [ -f "{{.ENCRYPTED_DIR}}/root-ca.pem.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.ROOT_CA_CERT_FILE}}" "{{.ENCRYPTED_DIR}}/root-ca.pem.age"
          echo "Decrypted $(basename "{{.ROOT_CA_CERT_FILE}}")"
        fi

        # Decrypt root-ca private key if it exists
        if [ -f "{{.ENCRYPTED_DIR}}/root-ca.key.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.ROOT_CA_KEY_FILE}}" "{{.ENCRYPTED_DIR}}/root-ca.key.age"
          chmod 600 "{{.ROOT_CA_KEY_FILE}}"
          echo "Decrypted $(basename "{{.ROOT_CA_KEY_FILE}}")"
        fi
        
        # Decrypt CRL if it exists
        if [ -f "{{.ENCRYPTED_DIR}}/crl.pem.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.SECRETS_DIR}}/crl.pem" "{{.ENCRYPTED_DIR}}/crl.pem.age"
          echo "Decrypted crl.pem"
        fi

        BASENAME="{{.SUB_CA_CERT_BASENAME}}"
        if [ -f "{{.ENCRYPTED_DIR}}/${BASENAME}.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.SUB_CA_CERT_FILE}}" "{{.ENCRYPTED_DIR}}/${BASENAME}.age"
          echo "Decrypted $BASENAME"
        fi

        if [ -f "{{.ENCRYPTED_DIR}}/sub-ca.key.age" ]; then
          age -d -i "{{.AGE_KEY_FILE}}" -o "{{.SUB_CA_KEY_FILE}}" "{{.ENCRYPTED_DIR}}/sub-ca.key.age"
          chmod 600 "{{.SUB_CA_KEY_FILE}}"
          echo "Decrypted sub-ca.key"
        fi
        
        echo "Secrets decrypted to {{.SECRETS_DIR}}/"
    status:
      - test -f "{{.SECRETS_DIR}}/init.json"

  clean:
    desc: Remove all unencrypted secrets and data (DANGEROUS)
    prompt: This will delete all unencrypted secrets and OpenBao data. Are you sure?
    cmds:
      - rm -rf "{{.SECRETS_DIR}}"
      - rm -rf data/
      - echo "Cleaned unencrypted secrets and data"
  
  reset:
    desc: Remove ALL secrets and data, encrypted or otherwise (DANGEROUS)
    prompt: This will delete all secrets and OpenBao data. Are you sure?
    cmds:
      - task: stop
      - rm -rf "{{.SECRETS_DIR}}"
      - rm -rf data/
      - rm -rf "{{.ENCRYPTED_DIR}}/*.age"
      - echo "Cleaned all secrets and data"

  status:
    desc: Show OpenBao status
    cmds:
      - |
        echo "OpenBao Status:"
        curl -s "{{.BAO_ADDR}}/v1/sys/health" | jq . 2>/dev/null || echo "OpenBao is not reachable"

  all:
    desc: "Run full setup: init, start, setup-root-ca, generate-sub-ca"
    summary: |
      This task is meant to be run from any stage of the setup process. 
      - If the age encrypted secrets are not yet decrypted, it will decrypt them.
      - If they are decrypted but OpenBao is not initialized, it will initialize it.
      - If OpenBao is initialized but the root CA is not set up, it will set it up.
      - Finally, it will generate the subordinate (issuing) CA.

      When completed, you should run the stop task to seal OpenBao and encrypt all secrets for safe keeping.
    cmds: 
      - task: start
      - task: setup-pki
      - task: setup-root-ca
      - task: load-root-ca
      #- generate-sub-ca

  show-certs:
    desc: Show certificate information for all PEM files in secrets directory
    silent: true
    cmds:
      - |
        if ! command -v openssl > /dev/null 2>&1; then
          echo "OpenSSL is required to display certificate information."
          exit 1
        fi
        
        if [ ! -d "{{.SECRETS_DIR}}" ]; then
          echo "Secrets directory not found: {{.SECRETS_DIR}}"
          exit 1
        fi
        
        FOUND=0
        for cert_file in "{{.SECRETS_DIR}}"/*.pem; do
          if [ -f "$cert_file" ]; then
            FOUND=1
            echo "═══════════════════════════════════════════════════════════════"
            echo "Certificate: $(basename "$cert_file")"
            echo "═══════════════════════════════════════════════════════════════"
            openssl x509 -in "$cert_file" -text -noout 2>/dev/null || echo "Not a valid certificate file"
            echo ""
          fi
        done
        
        if [ $FOUND -eq 0 ]; then
          echo "No PEM files found in {{.SECRETS_DIR}}"
        fi
  
  root:token:
    desc: Show the root token for OpenBao
    cmds:
      - |
        if [ ! -f "{{.SECRETS_DIR}}/init.json" ]; then
          echo "No init.json found. Run 'task setup-root-ca' first."
          exit 1
        fi
        
        ROOT_TOKEN=$(jq -r '.root_token' "{{.SECRETS_DIR}}/init.json")
        if [ -z "$ROOT_TOKEN" ] || [ "$ROOT_TOKEN" = "null" ]; then
          echo "Failed to retrieve root token from {{.SECRETS_DIR}}/init.json"
          exit 1
        fi
        
        echo "OpenBao Root Token:"
        echo "$ROOT_TOKEN"